{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 5666a5908db967e7ee44","webpack:///./src/interpreter.js","webpack:///./~/acorn/dist/acorn.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D,yBAAyB;AACzB,mCAAmC;AACnC,oBAAoB,iBAAiB,OAAO;AAC5C,2DAA2D;AAC3D,MAAM;AACN,gBAAgB;AAChB,IAAI;AACJ,EAAE,EAAE;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD,kCAAkC;AAClC,+EAA+E;AAC/E,cAAc;AACd,0BAA0B;AAC1B,8BAA8B;AAC9B,2CAA2C;AAC3C,WAAW;AACX,sBAAsB;AACtB,mEAAmE;AACnE,WAAW;AACX,MAAM;AACN,iBAAiB;AACjB,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,mDAAmD;AACnD,+BAA+B;AAC/B,4FAA4F;AAC5F,0BAA0B;AAC1B,8BAA8B;AAC9B,kBAAkB;AAClB,iEAAiE;AACjE,oBAAoB,SAAS,OAAO;AACpC,oBAAoB;AACpB,wBAAwB;AACxB,yDAAyD;AACzD,QAAQ;AACR,MAAM;AACN,gBAAgB;AAChB,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,oDAAoD;AACpD,gCAAgC;AAChC,6EAA6E;AAC7E,cAAc;AACd,0BAA0B;AAC1B,8BAA8B;AAC9B,2CAA2C;AAC3C,WAAW;AACX,sBAAsB;AACtB,gDAAgD;AAChD,WAAW;AACX,MAAM;AACN,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,gDAAgD;AAChD,gCAAgC;AAChC,uEAAuE;AACvE,iBAAiB;AACjB,0BAA0B;AAC1B,8BAA8B;AAC9B,2CAA2C;AAC3C,wBAAwB;AACxB,WAAW;AACX,sBAAsB;AACtB,uDAAuD;AACvD,WAAW;AACX,MAAM;AACN,cAAc;AACd,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,mDAAmD;AACnD,0CAA0C;AAC1C,6EAA6E;AAC7E,8DAA8D;AAC9D,iCAAiC;AACjC,4BAA4B;AAC5B,MAAM,OAAO;AACb,wCAAwC;AACxC,sBAAsB;AACtB,4EAA4E;AAC5E,QAAQ;AACR,sBAAsB;AACtB,MAAM;AACN,WAAW,SAAS,OAAO;AAC3B,uDAAuD;AACvD,MAAM;AACN,kBAAkB;AAClB,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,wDAAwD;AACxD,0CAA0C;AAC1C,6GAA6G;AAC7G,oEAAoE;AACpE,iCAAiC;AACjC,4BAA4B;AAC5B,MAAM,OAAO;AACb,uCAAuC;AACvC,mBAAmB;AACnB,4EAA4E;AAC5E,QAAQ;AACR,sBAAsB;AACtB,MAAM;AACN,WAAW,QAAQ,OAAO;AAC1B,uDAAuD;AACvD,MAAM;AACN,kBAAkB;AAClB,IAAI;AACJ,EAAE,EAAE;;AAEJ;AACA;AACA,iDAAiD;AACjD,+BAA+B;AAC/B,wEAAwE;AACxE,0BAA0B;AAC1B,8BAA8B;AAC9B,iEAAiE;AACjE,oBAAoB,SAAS,OAAO;AACpC,qDAAqD;AACrD,qBAAqB;AACrB,QAAQ;AACR,MAAM;AACN,kBAAkB;AAClB,IAAI;AACJ,EAAE,EAAE;;AAEJ,iDAAiD;AACjD,uBAAuB;AACvB,oBAAoB,iBAAiB,OAAO;AAC5C,uBAAuB;AACvB,sBAAsB,yBAAyB,OAAO;AACtD;AACA,0EAA0E;AAC1E,8BAA8B;AAC9B,iCAAiC;AACjC,8BAA8B;AAC9B,qBAAqB;AACrB,UAAU;AACV,QAAQ;AACR,+BAA+B;AAC/B,MAAM;AACN,iBAAiB;AACjB,IAAI;AACJ,EAAE,EAAE;;AAEJ,2DAA2D;AAC3D,eAAe;AACf,kBAAkB;AAClB,oBAAoB,iBAAiB,OAAO;AAC5C,4FAA4F;AAC5F,MAAM;AACN,0BAA0B;AAC1B,IAAI;AACJ,EAAE,EAAE;AACJ;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4CAA4C;AACvD;AACA,YAAY,2CAA2C;AACvD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,2CAA2C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2CAA2C;AACtD;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,2CAA2C;AACtD,WAAW,EAAE;AACb,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,2CAA2C;AACtD,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,EAAE;AACb,WAAW,yCAAyC;AACpD;AACA,WAAW,QAAQ;AACnB,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,EAAE;AACb,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,mBAAmB;AAC9B,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,2CAA2C;AACtD,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,2CAA2C;AACtD,WAAW,2CAA2C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA,GAAG;AACH;AACA,WAAW;AACX,GAAG;AACH,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kDAAkD;AAC7D;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,WAAW,kDAAkD;AAC7D;AACA,WAAW,2CAA2C;AACtD,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oCAAoC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8BAA8B;AAC3D,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD,KAAK;AACL;AACA;AACA,iCAAiC,4BAA4B;AAC7D,OAAO;AACP,iCAAiC,2BAA2B;AAC5D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,+BAA+B,sBAAsB;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA,GAAG;AACH;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,gBAAgB;AAC/C;AACA,GAAG;AACH;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+BAA+B,iBAAiB;AAChD;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D,KAAK;AACL;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C,GAAG;AACH;AACA,6BAA6B,iDAAiD;AAC9E,4BAA4B;AAC5B,GAAG;AACH;AACA,6BAA6B,qBAAqB;AAClD,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAsC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,GAAG;AACH;AACA;AACA,6BAA6B,8BAA8B;AAC3D,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC94GA;AACA;AACA;AACA,6CAA6C;AAC7C,CAAC,4BAA4B;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,8BAA8B;AAC5D;AACA,kBAAkB;AAClB,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,mCAAmC;AACnE;AACA,0BAA0B,IAAI,mCAAmC;AACjE,0BAA0B;AAC1B,8BAA8B,mCAAmC;AACjE;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,mCAAmC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,iCAAiC;AAC3D,+BAA+B,iCAAiC;AAChE,kCAAkC,8CAA8C;AAChF,mCAAmC,iDAAiD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAA2D;AAC5F;AACA;AACA;AACA,iCAAiC,iBAAiB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+BAA+B;AAChD;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C,iCAAiC,2BAA2B;AAC5D,yBAAyB,iDAAiD;AAC1E,qBAAqB,iDAAiD;AACtE,yBAAyB,iDAAiD;AAC1E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD,kEAAkE;;AAElE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wDAAwD;AACxD;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,4BAA4B,oDAAoD;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,wCAAwC;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,wDAAwD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO,YAAY,YAAY;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA,wDAAwD,0BAA0B,EAAE;AACpF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA,SAAS;AACT,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAA4C;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,oFAAoF,YAAY;AAChG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,cAAc;;AAE5D,CAAC,I","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"js-interpreter\"] = factory();\n\telse\n\t\troot[\"js-interpreter\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5666a5908db967e7ee44","/**\n * @license\n * JavaScript Interpreter\n *\n * Copyright 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\n/**\n * Create a new interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\n *     define APIs.  When called it is passed the interpreter object and the\n *     global scope object.\n * @constructor\n */\nvar acorn = require('acorn');\n\nvar Interpreter = function(code, opt_initFunc) {\n  if (typeof code == 'string') {\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  this.ast = code;\n  this.initFunc_ = opt_initFunc;\n  this.paused_ = false;\n  this.polyfills_ = [];\n  // Predefine some common primitives for performance.\n  this.UNDEFINED = new Interpreter.Primitive(undefined, this);\n  this.NULL = new Interpreter.Primitive(null, this);\n  this.NAN = new Interpreter.Primitive(NaN, this);\n  this.TRUE = new Interpreter.Primitive(true, this);\n  this.FALSE = new Interpreter.Primitive(false, this);\n  this.NUMBER_ZERO = new Interpreter.Primitive(0, this);\n  this.NUMBER_ONE = new Interpreter.Primitive(1, this);\n  this.STRING_EMPTY = new Interpreter.Primitive('', this);\n  // Create and initialize the global scope.\n  var scope = this.createScope(this.ast, null);\n  // Fix the parent properties now that the global scope exists.\n  //this.UNDEFINED.parent = undefined;\n  //this.NULL.parent = undefined;\n  this.NAN.parent = this.NUMBER;\n  this.TRUE.parent = this.BOOLEAN;\n  this.FALSE.parent = this.BOOLEAN;\n  this.NUMBER_ZERO.parent = this.NUMBER;\n  this.NUMBER_ONE.parent = this.NUMBER;\n  this.STRING_EMPTY.parent = this.STRING;\n  // Run the polyfills.\n  this.ast = acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\n  this.polyfills_ = undefined;  // Allow polyfill strings to garbage collect.\n  this.stripLocations_(this.ast);\n  this.stateStack = [{\n    node: this.ast,\n    scope: scope,\n    thisExpression: scope,\n    done: false\n  }];\n  this.run();\n  this.value = this.UNDEFINED;\n  // Point at the main program.\n  this.ast = code;\n  this.stateStack = [{\n    node: this.ast,\n    scope: scope,\n    thisExpression: scope,\n    done: false\n  }];\n};\n\n/**\n * @const {!Object} Configuration used for all Acorn parsing.\n */\nInterpreter.PARSE_OPTIONS = {\n  ecmaVersion: 5\n};\n\n/**\n * Property descriptor of readonly properties.\n */\nInterpreter.READONLY_DESCRIPTOR = {\n  configurable: true,\n  enumerable: true,\n  writable: false\n};\n\n/**\n * Property descriptor of non-enumerable properties.\n */\nInterpreter.NONENUMERABLE_DESCRIPTOR = {\n  configurable: true,\n  enumerable: false,\n  writable: true\n};\n\n/**\n * Property descriptor of readonly, non-enumerable properties.\n */\nInterpreter.READONLY_NONENUMERABLE_DESCRIPTOR = {\n  configurable: true,\n  enumerable: false,\n  writable: false\n};\n\n/**\n * Add more code to the interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n */\nInterpreter.prototype.appendCode = function(code) {\n  var state = this.stateStack[this.stateStack.length - 1];\n  if (!state || state.node.type != 'Program') {\n    throw Error('Expecting original AST to start with a Program node.');\n  }\n  if (typeof code == 'string') {\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  if (!code || code.type != 'Program') {\n    throw Error('Expecting new AST to start with a Program node.');\n  }\n  this.populateScope_(code, state.scope);\n  // Append the new program to the old one.\n  for (var i = 0, node; node = code.body[i]; i++) {\n    state.node.body.push(node);\n  }\n  state.done = false;\n};\n\n/**\n * Execute one step of the interpreter.\n * @return {boolean} True if a step was executed, false if no more instructions.\n */\nInterpreter.prototype.step = function() {\n  var state = this.stateStack[0];\n  if (!state || state.node.type == 'Program' && state.done) {\n    return false;\n  } else if (this.paused_) {\n    return true;\n  }\n  this['step' + state.node.type]();\n  if (!state.node.end) {\n    // This is polyfill code.  Keep executing until we arrive at user code.\n    return this.step();\n  }\n  return true;\n};\n\n/**\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\n * @return {boolean} True if a execution is asynchonously blocked,\n *     false if no more instructions.\n */\nInterpreter.prototype.run = function() {\n  while (!this.paused_ && this.step()) {}\n  return this.paused_;\n};\n\n/**\n * Initialize the global scope with buitin properties and functions.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initGlobalScope = function(scope) {\n  // Initialize uneditable global properties.\n  this.setProperty(scope, 'Infinity', this.createPrimitive(Infinity),\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'NaN', this.NAN,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'undefined', this.UNDEFINED,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'window', scope,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'self', scope); // Editable.\n\n  // Initialize global objects.\n  this.initFunction(scope);\n  this.initObject(scope);\n  // Unable to set scope's parent prior (this.OBJECT did not exist).\n  scope.parent = this.OBJECT;\n  this.initArray(scope);\n  this.initNumber(scope);\n  this.initString(scope);\n  this.initBoolean(scope);\n  this.initDate(scope);\n  this.initMath(scope);\n  this.initRegExp(scope);\n  this.initJSON(scope);\n  this.initError(scope);\n\n  // Initialize global functions.\n  var thisInterpreter = this;\n  var wrapper;\n  wrapper = function(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isNaN(num.toNumber()));\n  };\n  this.setProperty(scope, 'isNaN',\n                   this.createNativeFunction(wrapper));\n\n  wrapper = function(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isFinite(num.toNumber()));\n  };\n  this.setProperty(scope, 'isFinite',\n                   this.createNativeFunction(wrapper));\n\n  this.setProperty(scope, 'parseFloat',\n                   this.getProperty(this.NUMBER, 'parseFloat'));\n\n  this.setProperty(scope, 'parseInt',\n                   this.getProperty(this.NUMBER, 'parseInt'));\n\n  var func = this.createObject(this.FUNCTION);\n  func.eval = true;\n  this.setProperty(func, 'length', this.NUMBER_ONE,\n                   Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'eval', func);\n\n  var strFunctions = [\n    [escape, 'escape'], [unescape, 'unescape'],\n    [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\n    [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\n  ];\n  for (var i = 0; i < strFunctions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function(str) {\n        str = (str || thisInterpreter.UNDEFINED).toString();\n        try {\n          str = nativeFunc(str);\n        } catch (e) {\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\n        }\n        return thisInterpreter.createPrimitive(str);\n      };\n    })(strFunctions[i][0]);\n    this.setProperty(scope, strFunctions[i][1],\n                     this.createNativeFunction(wrapper));\n  }\n\n  // Run any user-provided initialization.\n  if (this.initFunc_) {\n    this.initFunc_(this, scope);\n  }\n};\n\n/**\n * Initialize the Function class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initFunction = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Function constructor.\n  wrapper = function(var_args) {\n    if (this.parent == thisInterpreter.FUNCTION) {\n      // Called with new.\n      var newFunc = this;\n    } else {\n      var newFunc = thisInterpreter.createObject(thisInterpreter.FUNCTION);\n    }\n    if (arguments.length) {\n      var code = arguments[arguments.length - 1].toString();\n    } else {\n      var code = '';\n    }\n    var args = [];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i].toString());\n    }\n    args = args.join(', ');\n    if (args.indexOf(')') != -1) {\n      throw SyntaxError('Function arg string contains parenthesis');\n    }\n    // Interestingly, the scope for constructed functions is the global scope,\n    // even if they were constructed in some other scope.\n    newFunc.parentScope =\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1].scope;\n    var ast = acorn.parse('$ = function(' + args + ') {' + code + '};',\n        Interpreter.PARSE_OPTIONS);\n    newFunc.node = ast.body[0].expression.right;\n    thisInterpreter.setProperty(newFunc, 'length',\n        thisInterpreter.createPrimitive(newFunc.node.length),\n        Interpreter.READONLY_DESCRIPTOR);\n    return newFunc;\n  };\n  this.FUNCTION = this.createObject(null);\n  this.setProperty(scope, 'Function', this.FUNCTION);\n  // Manually setup type and prototype because createObj doesn't recognize\n  // this object as a function (this.FUNCTION did not exist).\n  this.FUNCTION.type = 'function';\n  this.setProperty(this.FUNCTION, 'prototype', this.createObject(null));\n  this.FUNCTION.nativeFunc = wrapper;\n\n  wrapper = function(thisArg, args) {\n    var state = thisInterpreter.stateStack[0];\n    // Rewrite the current 'CallExpression' to apply a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = thisArg;\n    // Bind any provided arguments.\n    state.arguments = [];\n    if (args) {\n      if (thisInterpreter.isa(args, thisInterpreter.ARRAY)) {\n        for (var i = 0; i < args.length; i++) {\n          state.arguments[i] = thisInterpreter.getProperty(args, i);\n        }\n      } else {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n            'CreateListFromArrayLike called on non-object');\n      }\n    }\n    state.doneArgs_ = true;\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\n\n  wrapper = function(thisArg, var_args) {\n    var state = thisInterpreter.stateStack[0];\n    // Rewrite the current 'CallExpression' to call a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = thisArg;\n    // Bind any provided arguments.\n    state.arguments = [];\n    for (var i = 1; i < arguments.length; i++) {\n      state.arguments.push(arguments[i]);\n    }\n    state.doneArgs_ = true;\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\n\n  wrapper = function(thisArg, var_args) {\n    // Clone function\n    var clone = thisInterpreter.createFunction(this.node, this.parentScope);\n    // Assign the 'this' object.\n    if (thisArg) {\n      clone.boundThis_ = thisArg;\n    }\n    // Bind any provided arguments.\n    clone.boundArgs_ = [];\n    for (var i = 1; i < arguments.length; i++) {\n      clone.boundArgs_.push(arguments[i]);\n    }\n    return clone;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'bind', wrapper);\n  // Function has no parent to inherit from, so it needs its own mandatory\n  // toString and valueOf functions.\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\n  this.setProperty(this.FUNCTION, 'toString',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\n  this.setProperty(this.FUNCTION, 'valueOf',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Initialize the Object class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initObject = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Object constructor.\n  wrapper = function(value) {\n    if (!value || value == thisInterpreter.UNDEFINED ||\n        value == thisInterpreter.NULL) {\n      // Create a new object.\n      if (this.parent == thisInterpreter.OBJECT) {\n        // Called with new.\n        return this;\n      } else {\n        return thisInterpreter.createObject(thisInterpreter.OBJECT);\n      }\n    }\n    if (value.isPrimitive) {\n      // Wrap the value as an object.\n      var obj = thisInterpreter.createObject(value.parent);\n      obj.data = value.data;\n      return obj;\n    }\n    // Return the provided object.\n    return value;\n  };\n  this.OBJECT = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Object', this.OBJECT);\n\n  // Static methods on Object.\n  wrapper = function(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      if (obj.notEnumerable[key]) {\n        continue;\n      }\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'keys',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj, prop, descriptor) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    if (!(descriptor instanceof Interpreter.Object)) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Property description must be an object.');\n      return;\n    }\n    if (!obj.properties[prop] && obj.preventExtensions) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Can\\'t define property ' + prop + ', object is not extensible');\n      return;\n    }\n    var value = thisInterpreter.getProperty(descriptor, 'value');\n    if (value == thisInterpreter.UNDEFINED) {\n      value = null;\n    }\n    var get = thisInterpreter.getProperty(descriptor, 'get');\n    var set = thisInterpreter.getProperty(descriptor, 'set');\n    var nativeDescriptor = {\n      configurable: thisInterpreter.pseudoToNative(\n          /** @type !Interpreter.Primitive */\n          (thisInterpreter.getProperty(descriptor, 'configurable'))),\n      enumerable: thisInterpreter.pseudoToNative(\n          /** @type !Interpreter.Primitive */\n          (thisInterpreter.getProperty(descriptor, 'enumerable'))),\n      writable: thisInterpreter.pseudoToNative(\n          /** @type !Interpreter.Primitive */\n          (thisInterpreter.getProperty(descriptor, 'writable'))),\n      get: get == thisInterpreter.UNDEFINED ? undefined : get,\n      set: set == thisInterpreter.UNDEFINED ? undefined : set\n    };\n    thisInterpreter.setProperty(obj, prop, value, nativeDescriptor);\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'defineProperty',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  this.polyfills_.push(\n\"Object.defineProperty(Array.prototype, 'defineProperties', {configurable: true, value:\",\n  \"function(obj, props) {\",\n    \"var keys = Object.keys(props);\",\n    \"for (var i = 0; i < keys.length; i++) {\",\n      \"Object.defineProperty(obj, keys[i], props[keys[i]]);\",\n    \"}\",\n    \"return obj;\",\n  \"}\",\n\"});\",\n\"\");\n\n  wrapper = function(obj, prop) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    if (!(prop in obj.properties)) {\n      return thisInterpreter.UNDEFINED;\n    }\n    var configurable = !obj.notConfigurable[prop];\n    var enumerable = !obj.notEnumerable[prop];\n    var writable = !obj.notWritable[prop];\n    var getter = obj.getter[prop];\n    var setter = obj.setter[prop];\n\n    var descriptor = thisInterpreter.createObject(thisInterpreter.OBJECT);\n    thisInterpreter.setProperty(descriptor, 'configurable',\n        thisInterpreter.createPrimitive(configurable));\n    thisInterpreter.setProperty(descriptor, 'enumerable',\n        thisInterpreter.createPrimitive(enumerable));\n    if (getter || setter) {\n      thisInterpreter.setProperty(descriptor, 'getter', getter);\n      thisInterpreter.setProperty(descriptor, 'setter', setter);\n    } else {\n      thisInterpreter.setProperty(descriptor, 'writable',\n          thisInterpreter.createPrimitive(writable));\n      thisInterpreter.setProperty(descriptor, 'value',\n          thisInterpreter.getProperty(obj, prop));\n    }\n    return descriptor;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    if (obj.parent && obj.parent.properties &&\n        obj.parent.properties.prototype) {\n      return obj.parent.properties.prototype;\n    }\n    return thisInterpreter.NULL;\n  };\n  this.setProperty(this.OBJECT, 'getPrototypeOf',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    return thisInterpreter.createPrimitive(!obj.preventExtensions);\n  };\n  this.setProperty(this.OBJECT, 'isExtensible',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(obj) {\n    if (!obj.isPrimitive) {\n      obj.preventExtensions = true;\n    }\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'preventExtensions',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Object.\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'toString', wrapper);\n\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString', wrapper);\n\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'valueOf', wrapper);\n\n  wrapper = function(prop) {\n    if (this == thisInterpreter.NULL || this == thisInterpreter.UNDEFINED) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR,\n          'Cannot convert undefined or null to object');\n      return;\n    }\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    return (prop in this.properties) ?\n        thisInterpreter.TRUE : thisInterpreter.FALSE;\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\n\n  wrapper = function(prop) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    var enumerable = prop in this.properties && !this.notEnumerable[prop];\n    return thisInterpreter.createPrimitive(enumerable);\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\n\n  wrapper = function(obj) {\n    while (true) {\n      if (obj.parent && obj.parent.properties &&\n          obj.parent.properties.prototype) {\n        obj = obj.parent.properties.prototype;\n        if (obj == this) {\n          return thisInterpreter.createPrimitive(true);\n        }\n      } else {\n        // No parent, reached the top.\n        return thisInterpreter.createPrimitive(false);\n      }\n    }\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf',  wrapper);\n};\n\n/**\n * Initialize the Array class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initArray = function(scope) {\n  var thisInterpreter = this;\n  var getInt = function(obj, def) {\n    // Return an integer, or the default.\n    var n = obj ? Math.floor(obj.toNumber()) : def;\n    if (isNaN(n)) {\n      n = def;\n    }\n    return n;\n  };\n  var strictComp = function(a, b) {\n    // Strict === comparison.\n    if (a.isPrimitive && b.isPrimitive) {\n      return a.data === b.data;\n    }\n    return a === b;\n  };\n  var wrapper;\n  // Array constructor.\n  wrapper = function(var_args) {\n    if (this.parent == thisInterpreter.ARRAY) {\n      // Called with new.\n      var newArray = this;\n    } else {\n      var newArray = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    }\n    var first = arguments[0];\n    if (first && first.type == 'number') {\n      if (isNaN(thisInterpreter.arrayIndex(first))) {\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR,\n                                       'Invalid array length');\n      }\n      newArray.length = first.data;\n    } else {\n      for (var i = 0; i < arguments.length; i++) {\n        newArray.properties[i] = arguments[i];\n      }\n      newArray.length = i;\n    }\n    return newArray;\n  };\n  this.ARRAY = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Array', this.ARRAY);\n\n  // Static methods on Array.\n  wrapper = function(obj) {\n    return thisInterpreter.createPrimitive(\n        thisInterpreter.isa(obj, thisInterpreter.ARRAY));\n  };\n  this.setProperty(this.ARRAY, 'isArray',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Array.\n  wrapper = function() {\n    if (this.length) {\n      var value = this.properties[this.length - 1];\n      delete this.properties[this.length - 1];\n      this.length--;\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\n\n  wrapper = function(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[this.length] = arguments[i];\n      this.length++;\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\n\n  wrapper = function() {\n    if (this.length) {\n      var value = this.properties[0];\n      for (var i = 1; i < this.length; i++) {\n        this.properties[i - 1] = this.properties[i];\n      }\n      this.length--;\n      delete this.properties[this.length];\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\n\n  wrapper = function(var_args) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      this.properties[i + arguments.length] = this.properties[i];\n    }\n    this.length += arguments.length;\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[i] = arguments[i];\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\n\n  wrapper = function() {\n    for (var i = 0; i < this.length / 2; i++) {\n      var tmp = this.properties[this.length - i - 1];\n      this.properties[this.length - i - 1] = this.properties[i];\n      this.properties[i] = tmp;\n    }\n    return this;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\n\n  wrapper = function(index, howmany, var_args) {\n    index = getInt(index, 0);\n    if (index < 0) {\n      index = Math.max(this.length + index, 0);\n    } else {\n      index = Math.min(index, this.length);\n    }\n    howmany = getInt(howmany, Infinity);\n    howmany = Math.min(howmany, this.length - index);\n    var removed = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    // Remove specified elements.\n    for (var i = index; i < index + howmany; i++) {\n      removed.properties[removed.length++] = this.properties[i];\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Move other element to fill the gap.\n    for (var i = index + howmany; i < this.length - howmany; i++) {\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Delete superfluous properties.\n    for (var i = this.length - howmany; i < this.length; i++) {\n      delete this.properties[i];\n    }\n    this.length -= howmany;\n    // Insert specified items.\n    for (var i = this.length - 1; i >= index; i--) {\n      this.properties[i + arguments.length - 2] = this.properties[i];\n    }\n    this.length += arguments.length - 2;\n    for (var i = 2; i < arguments.length; i++) {\n      this.properties[index + i - 2] = arguments[i];\n    }\n    return removed;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\n\n  wrapper = function(opt_begin, opt_end) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var begin = getInt(opt_begin, 0);\n    if (begin < 0) {\n      begin = this.length + begin;\n    }\n    begin = Math.max(0, Math.min(begin, this.length));\n    var end = getInt(opt_end, this.length);\n    if (end < 0) {\n      end = this.length + end;\n    }\n    end = Math.max(0, Math.min(end, this.length));\n    var length = 0;\n    for (var i = begin; i < end; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    return list;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\n\n  wrapper = function(opt_separator) {\n    if (!opt_separator || opt_separator.data === undefined) {\n      var sep = undefined;\n    } else {\n      var sep = opt_separator.toString();\n    }\n    var text = [];\n    for (var i = 0; i < this.length; i++) {\n      text[i] = this.properties[i];\n    }\n    return thisInterpreter.createPrimitive(text.join(sep));\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\n\n  wrapper = function(var_args) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var length = 0;\n    // Start by copying the current array.\n    for (var i = 0; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    // Loop through all arguments and copy them in.\n    for (var i = 0; i < arguments.length; i++) {\n      var value = arguments[i];\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\n        for (var j = 0; j < value.length; j++) {\n          var element = thisInterpreter.getProperty(value, j);\n          thisInterpreter.setProperty(list, length++, element);\n        }\n      } else {\n        thisInterpreter.setProperty(list, length++, value);\n      }\n    }\n    return list;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, 0);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.max(0, fromIndex);\n    for (var i = fromIndex; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, this.length);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.min(fromIndex, this.length - 1);\n    for (var i = fromIndex; i >= 0; i--) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\n\n  this.polyfills_.push(\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\n\"Object.defineProperty(Array.prototype, 'every', {configurable: true, value:\",\n  \"function(callbackfn, thisArg) {\",\n    \"if (this == null || typeof callbackfn !== 'function') throw new TypeError;\",\n    \"var T, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\",\n      \"k++;\",\n    \"}\",\n    \"return true;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n\"Object.defineProperty(Array.prototype, 'filter', {configurable: true, value:\",\n  \"function(fun/*, thisArg*/) {\",\n    \"if (this === void 0 || this === null || typeof fun !== 'function') throw new TypeError;\",\n    \"var t = Object(this);\",\n    \"var len = t.length >>> 0;\",\n    \"var res = [];\",\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\n    \"for (var i = 0; i < len; i++) {\",\n      \"if (i in t) {\",\n        \"var val = t[i];\",\n        \"if (fun.call(thisArg, val, i, t)) res.push(val);\",\n      \"}\",\n    \"}\",\n    \"return res;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n\"Object.defineProperty(Array.prototype, 'forEach', {configurable: true, value:\",\n  \"function(callback, thisArg) {\",\n    \"if (this == null || typeof callback !== 'function') throw new TypeError;\",\n    \"var T, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O) callback.call(T, O[k], k, O);\",\n      \"k++;\",\n    \"}\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n\"Object.defineProperty(Array.prototype, 'map', {configurable: true, value:\",\n  \"function(callback, thisArg) {\",\n    \"if (this == null || typeof callback !== 'function') new TypeError;\",\n    \"var T, A, k;\",\n    \"var O = Object(this);\",\n    \"var len = O.length >>> 0;\",\n    \"if (arguments.length > 1) T = thisArg;\",\n    \"A = new Array(len);\",\n    \"k = 0;\",\n    \"while (k < len) {\",\n      \"if (k in O) A[k] = callback.call(T, O[k], k, O);\",\n      \"k++;\",\n    \"}\",\n    \"return A;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n\"Object.defineProperty(Array.prototype, 'reduce', {configurable: true, value:\",\n  \"function(callback /*, initialValue*/) {\",\n    \"if (this == null || typeof callback !== 'function') throw new TypeError;\",\n    \"var t = Object(this), len = t.length >>> 0, k = 0, value;\",\n    \"if (arguments.length == 2) {\",\n      \"value = arguments[1];\",\n    \"} else {\",\n      \"while (k < len && !(k in t)) k++;\",\n      \"if (k >= len) {\",\n        \"throw new TypeError('Reduce of empty array with no initial value');\",\n      \"}\",\n      \"value = t[k++];\",\n    \"}\",\n    \"for (; k < len; k++) {\",\n      \"if (k in t) value = callback(value, t[k], k, t);\",\n    \"}\",\n    \"return value;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\n\"Object.defineProperty(Array.prototype, 'reduceRight', {configurable: true, value:\",\n  \"function(callback /*, initialValue*/) {\",\n    \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw new TypeError;\",\n    \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\",\n    \"if (arguments.length >= 2) {\",\n      \"value = arguments[1];\",\n    \"} else {\",\n      \"while (k >= 0 && !(k in t)) k--;\",\n      \"if (k < 0) {\",\n        \"throw new TypeError('Reduce of empty array with no initial value');\",\n      \"}\",\n      \"value = t[k--];\",\n    \"}\",\n    \"for (; k >= 0; k--) {\",\n      \"if (k in t) value = callback(value, t[k], k, t);\",\n    \"}\",\n    \"return value;\",\n  \"}\",\n\"});\",\n\n// Polyfill copied from:\n// developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n\"Object.defineProperty(Array.prototype, 'some', {configurable: true, value:\",\n  \"function(fun/*, thisArg*/) {\",\n    \"if (this == null || typeof fun !== 'function') throw new TypeError;\",\n    \"var t = Object(this);\",\n    \"var len = t.length >>> 0;\",\n    \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\",\n    \"for (var i = 0; i < len; i++) {\",\n      \"if (i in t && fun.call(thisArg, t[i], i, t)) {\",\n        \"return true;\",\n      \"}\",\n    \"}\",\n    \"return false;\",\n  \"}\",\n\"});\",\n\n\"Object.defineProperty(Array.prototype, 'sort', {configurable: true, value:\",\n  \"function(opt_comp) {\",\n    \"for (var i = 0; i < this.length; i++) {\",\n      \"var changes = 0;\",\n      \"for (var j = 0; j < this.length - i - 1; j++) {\",\n        \"if (opt_comp ?\" +\n            \"opt_comp(this[j], this[j + 1]) > 0 : this[j] > this[j + 1]) {\",\n          \"var swap = this[j];\",\n          \"this[j] = this[j + 1];\",\n          \"this[j + 1] = swap;\",\n          \"changes++;\",\n        \"}\",\n      \"}\",\n      \"if (changes <= 1) break;\",\n    \"}\",\n    \"return this;\",\n  \"}\",\n\"});\",\n\n\"Object.defineProperty(Array.prototype, 'toLocaleString', {configurable: true, value:\",\n  \"function() {\",\n    \"var out = [];\",\n    \"for (var i = 0; i < this.length; i++) {\",\n      \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\",\n    \"}\",\n    \"return out.join(',');\",\n  \"}\",\n\"});\",\n\"\");\n};\n\n/**\n * Initialize the Number class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initNumber = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Number constructor.\n  wrapper = function(value) {\n    value = value ? value.toNumber() : 0;\n    if (this.parent != thisInterpreter.NUMBER) {\n      // Called as Number().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Number().\n    this.data = value;\n    return this;\n  };\n  this.NUMBER = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Number', this.NUMBER);\n\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\n                   'POSITIVE_INFINITY'];\n  for (var i = 0; i < numConsts.length; i++) {\n    this.setProperty(this.NUMBER, numConsts[i],\n                     this.createPrimitive(Number[numConsts[i]]));\n  }\n\n  // Static methods on Number.\n  wrapper = function(str) {\n    str = str || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(parseFloat(str.toString()));\n  };\n  this.setProperty(this.NUMBER, 'parseFloat',\n                   this.createNativeFunction(wrapper));\n\n  wrapper = function(str, radix) {\n    str = str || thisInterpreter.UNDEFINED;\n    radix = radix || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(\n        parseInt(str.toString(), radix.toNumber()));\n  };\n  this.setProperty(this.NUMBER, 'parseInt',\n                   this.createNativeFunction(wrapper));\n\n  // Instance methods on Number.\n  wrapper = function(fractionDigits) {\n    fractionDigits = fractionDigits ? fractionDigits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toExponential(fractionDigits));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\n\n  wrapper = function(digits) {\n    digits = digits ? digits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toFixed(digits));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\n\n  wrapper = function(precision) {\n    precision = precision ? precision.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toPrecision(precision));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\n\n  wrapper = function(radix) {\n    radix = radix ? radix.toNumber() : 10;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toString(radix));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\n\n  wrapper = function(locales, options) {\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return thisInterpreter.createPrimitive(\n        this.toNumber().toLocaleString(locales, options));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\n};\n\n/**\n * Initialize the String class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initString = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // String constructor.\n  wrapper = function(value) {\n    value = value ? value.toString() : '';\n    if (this.parent != thisInterpreter.STRING) {\n      // Called as String().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new String().\n    this.data = value;\n    return this;\n  };\n  this.STRING = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'String', this.STRING);\n\n  // Static methods on String.\n  wrapper = function(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      arguments[i] = arguments[i].toNumber();\n    }\n    return thisInterpreter.createPrimitive(\n        String.fromCharCode.apply(String, arguments));\n  };\n  this.setProperty(this.STRING, 'fromCharCode',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on String.\n  // Methods with no arguments.\n  var functions = ['toLowerCase', 'toUpperCase',\n                   'toLocaleLowerCase', 'toLocaleUpperCase'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function() {\n        return thisInterpreter.createPrimitive(nativeFunc.apply(this));\n      };\n    })(String.prototype[functions[i]]);\n    this.setNativeFunctionPrototype(this.STRING, functions[i], wrapper);\n  }\n\n  // Trim function may not exist in host browser.  Write them from scratch.\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+|\\s+$/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trim', wrapper);\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trimLeft', wrapper);\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/\\s+$/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trimRight', wrapper);\n\n  // Methods with only numeric arguments.\n  functions = ['charAt', 'charCodeAt', 'substring', 'slice', 'substr'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function() {\n        for (var j = 0; j < arguments.length; j++) {\n          arguments[j] = arguments[j].toNumber();\n        }\n        return thisInterpreter.createPrimitive(\n            nativeFunc.apply(this, arguments));\n      };\n    })(String.prototype[functions[i]]);\n    this.setNativeFunctionPrototype(this.STRING, functions[i], wrapper);\n  }\n\n  wrapper = function(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(\n        str.indexOf(searchValue, fromIndex));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'indexOf', wrapper);\n\n  wrapper = function(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(\n        str.lastIndexOf(searchValue, fromIndex));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'lastIndexOf', wrapper);\n\n  wrapper = function(compareString, locales, options) {\n    compareString = (compareString || thisInterpreter.UNDEFINED).toString();\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return thisInterpreter.createPrimitive(\n        this.toString().localeCompare(compareString, locales, options));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\n\n  wrapper = function(separator, limit) {\n    var str = this.toString();\n    if (separator) {\n      separator = thisInterpreter.isa(separator, thisInterpreter.REGEXP) ?\n          separator.data : separator.toString();\n    } else { // is this really necessary?\n      separator = undefined;\n    }\n    limit = limit ? limit.toNumber() : undefined;\n    var jsList = str.split(separator, limit);\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < jsList.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(jsList[i]));\n    }\n    return pseudoList;\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\n\n  wrapper = function(var_args) {\n    var str = this.toString();\n    for (var i = 0; i < arguments.length; i++) {\n      str += arguments[i].toString();\n    }\n    return thisInterpreter.createPrimitive(str);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'concat', wrapper);\n\n  wrapper = function(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    var match = str.match(regexp);\n    if (match === null) {\n      return thisInterpreter.NULL;\n    }\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < match.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(match[i]));\n    }\n    return pseudoList;\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\n\n  wrapper = function(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    return thisInterpreter.createPrimitive(str.search(regexp));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\n\n  wrapper = function(substr, newSubStr) {\n    var str = this.toString();\n    substr = (substr || thisInterpreter.UNDEFINED).valueOf();\n    newSubStr = (newSubStr || thisInterpreter.UNDEFINED).toString();\n    return thisInterpreter.createPrimitive(str.replace(substr, newSubStr));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\n};\n\n/**\n * Initialize the Boolean class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initBoolean = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Boolean constructor.\n  wrapper = function(value) {\n    value = value ? value.toBoolean() : false;\n    if (this.parent != thisInterpreter.BOOLEAN) {\n      // Called as Boolean().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Boolean().\n    this.data = value;\n    return this;\n  };\n  this.BOOLEAN = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\n};\n\n/**\n * Initialize the Date class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initDate = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Date constructor.\n  wrapper = function(a, b, c, d, e, f, h) {\n    if (this.parent == thisInterpreter.DATE) {\n      // Called with new.\n      var newDate = this;\n    } else {\n      // Calling Date() as a function returns a string, no arguments are heeded.\n      return thisInterpreter.createPrimitive(Date());\n    }\n    if (!arguments.length) {\n      newDate.data = new Date();\n    } else if (arguments.length == 1 && (a.type == 'string' ||\n        thisInterpreter.isa(a, thisInterpreter.STRING))) {\n      newDate.data = new Date(a.toString());\n    } else {\n      var args = [null];\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i] ? arguments[i].toNumber() : undefined;\n      }\n      newDate.data = new (Function.prototype.bind.apply(Date, args));\n    }\n    return newDate;\n  };\n  this.DATE = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Date', this.DATE);\n\n  // Static methods on Date.\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(new Date().getTime());\n  };\n  this.setProperty(this.DATE, 'now',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(dateString) {\n    dateString = dateString ? dateString.toString() : undefined;\n    return thisInterpreter.createPrimitive(Date.parse(dateString));\n  };\n  this.setProperty(this.DATE, 'parse',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(a, b, c, d, e, f, h) {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i] ? arguments[i].toNumber() : undefined;\n    }\n    return thisInterpreter.createPrimitive(Date.UTC.apply(Date, args));\n  };\n  this.setProperty(this.DATE, 'UTC',\n      this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Date.\n  var functions = ['getDate', 'getDay', 'getFullYear', 'getHours',\n      'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\n      'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\n      'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\n      'getUTCSeconds', 'getYear',\n      'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\n      'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\n      'setUTCMonth', 'setUTCSeconds', 'setYear',\n      'toDateString', 'toISOString', 'toJSON', 'toGMTString',\n      'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\n      'toTimeString', 'toUTCString'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function(var_args) {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args[i] = thisInterpreter.pseudoToNative(arguments[i]);\n        }\n        return thisInterpreter.createPrimitive(\n            this.data[nativeFunc].apply(this.data, args));\n      };\n    })(functions[i]);\n    this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\n  }\n};\n\n/**\n * Initialize Math object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initMath = function(scope) {\n  var thisInterpreter = this;\n  var myMath = this.createObject(this.OBJECT);\n  this.setProperty(scope, 'Math', myMath);\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\n                    'SQRT1_2', 'SQRT2'];\n  for (var i = 0; i < mathConsts.length; i++) {\n    this.setProperty(myMath, mathConsts[i],\n        this.createPrimitive(Math[mathConsts[i]]),\n        Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  }\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\n                      'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\n                      'round', 'sin', 'sqrt', 'tan'];\n  for (var i = 0; i < numFunctions.length; i++) {\n    var wrapper = (function(nativeFunc) {\n      return function() {\n        for (var j = 0; j < arguments.length; j++) {\n          arguments[j] = arguments[j].toNumber();\n        }\n        return thisInterpreter.createPrimitive(\n            nativeFunc.apply(Math, arguments));\n      };\n    })(Math[numFunctions[i]]);\n    this.setProperty(myMath, numFunctions[i],\n        this.createNativeFunction(wrapper),\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n};\n\n/**\n * Initialize Regular Expression object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initRegExp = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Regex constructor.\n  wrapper = function(pattern, flags) {\n    if (this.parent == thisInterpreter.REGEXP) {\n      // Called with new.\n      var rgx = this;\n    } else {\n      var rgx = thisInterpreter.createObject(thisInterpreter.REGEXP);\n    }\n    pattern = pattern ? pattern.toString() : '';\n    flags = flags ? flags.toString() : '';\n    return thisInterpreter.populateRegExp_(rgx, new RegExp(pattern, flags));\n  };\n  this.REGEXP = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'RegExp', this.REGEXP);\n\n  this.setProperty(this.REGEXP.properties.prototype, 'global',\n      this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'ignoreCase',\n      this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'multiline',\n      this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'source',\n      this.createPrimitive('(?:)'),\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function(str) {\n    str = str.toString();\n    return thisInterpreter.createPrimitive(this.data.test(str));\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\n\n  wrapper = function(str) {\n    str = str.toString();\n    // Get lastIndex from wrapped regex, since this is settable.\n    this.data.lastIndex =\n        thisInterpreter.getProperty(this, 'lastIndex').toNumber();\n    var match = this.data.exec(str);\n    thisInterpreter.setProperty(this, 'lastIndex',\n        thisInterpreter.createPrimitive(this.data.lastIndex));\n\n    if (match) {\n      var result = thisInterpreter.createObject(thisInterpreter.ARRAY);\n      for (var i = 0; i < match.length; i++) {\n        thisInterpreter.setProperty(result, i,\n            thisInterpreter.createPrimitive(match[i]));\n      }\n      // match has additional properties.\n      thisInterpreter.setProperty(result, 'index',\n          thisInterpreter.createPrimitive(match.index));\n      thisInterpreter.setProperty(result, 'input',\n          thisInterpreter.createPrimitive(match.input));\n      return result;\n    }\n    return thisInterpreter.NULL;\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\n};\n\n/**\n * Initialize JSON object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initJSON = function(scope) {\n  var thisInterpreter = this;\n  var myJSON = thisInterpreter.createObject(this.OBJECT);\n  this.setProperty(scope, 'JSON', myJSON);\n\n  var wrapper = function(text) {\n    try {\n      var nativeObj = JSON.parse(text.toString());\n    } catch (e) {\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\n      return;\n    }\n    return thisInterpreter.nativeToPseudo(nativeObj);\n  };\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper));\n\n  wrapper = function(value) {\n    var nativeObj = thisInterpreter.pseudoToNative(value);\n    return thisInterpreter.createPrimitive(JSON.stringify(nativeObj));\n  };\n  this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper));\n};\n\n/**\n * Initialize the Error class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initError = function(scope) {\n  var thisInterpreter = this;\n  // Error constructor.\n  this.ERROR = this.createNativeFunction(function(opt_message) {\n    if (this.parent == thisInterpreter.ERROR) {\n      // Called with new.\n      var newError = this;\n    } else {\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\n    }\n    if (opt_message) {\n      thisInterpreter.setProperty(newError, 'message',\n          thisInterpreter.createPrimitive(String(opt_message)),\n          Interpreter.NONENUMERABLE_DESCRIPTOR);\n    }\n    return newError;\n  });\n  this.setProperty(scope, 'Error', this.ERROR);\n  this.setProperty(this.ERROR.properties.prototype, 'message',\n      this.STRING_EMPTY, Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.ERROR.properties.prototype, 'name',\n      this.createPrimitive('Error'), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  var createErrorSubclass = function(name) {\n    var constructor = thisInterpreter.createNativeFunction(\n        function(opt_message) {\n          if (thisInterpreter.isa(this.parent, thisInterpreter.ERROR)) {\n            // Called with new.\n            var newError = this;\n          } else {\n            var newError = thisInterpreter.createObject(constructor);\n          }\n          if (opt_message) {\n            thisInterpreter.setProperty(newError, 'message',\n                thisInterpreter.createPrimitive(String(opt_message)),\n                Interpreter.NONENUMERABLE_DESCRIPTOR);\n          }\n          return newError;\n        });\n    thisInterpreter.setProperty(constructor, 'prototype',\n        thisInterpreter.createObject(thisInterpreter.ERROR));\n    thisInterpreter.setProperty(constructor.properties.prototype, 'name',\n        thisInterpreter.createPrimitive(name),\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n    thisInterpreter.setProperty(scope, name, constructor);\n\n    return constructor;\n  };\n\n  this.EVAL_ERROR = createErrorSubclass('EvalError');\n  this.RANGE_ERROR = createErrorSubclass('RangeError');\n  this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\n  this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\n  this.TYPE_ERROR = createErrorSubclass('TypeError');\n  this.URI_ERROR = createErrorSubclass('URIError');\n};\n\n/**\n * Is an object of a certain class?\n * @param {Object} child Object to check.\n * @param {Object} parent Constructor of object.\n * @return {boolean} True if object is the class or inherits from it.\n *     False otherwise.\n */\nInterpreter.prototype.isa = function(child, parent) {\n  if (!child || !parent) {\n    return false;\n  }\n  while (child.parent != parent) {\n    if (!child.parent || !child.parent.properties.prototype) {\n      return false;\n    }\n    child = child.parent.properties.prototype;\n  }\n  return true;\n};\n\n/**\n * Compares two objects against each other.\n * @param {!Object} a First object.\n * @param {!Object} b Second object.\n * @return {number} -1 if a is smaller, 0 if a == b, 1 if a is bigger,\n *     NaN if they are not comparable.\n */\nInterpreter.prototype.comp = function(a, b) {\n  if (a.isPrimitive && isNaN(a.data) ||\n      b.isPrimitive && isNaN(b.data)) {\n    // NaN is not comparable to anything, including itself.\n    return NaN;\n  }\n  if (a === b) {\n    return 0;\n  }\n  var aValue =\n        a.isPrimitive ? a.data : a.toString();\n  var bValue =\n        b.isPrimitive ? b.data : b.toString();\n  if (aValue < bValue) {\n    return -1;\n  } else if (aValue > bValue) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Is a value a legal integer for an array?\n * @param {*} n Value to check.\n * @return {number} Zero, or a positive integer if the value can be\n *     converted to such.  NaN otherwise.\n */\nInterpreter.prototype.arrayIndex = function(n) {\n  n = Number(n);\n  if (!isFinite(n) || n != Math.floor(n) || n < 0) {\n    return NaN;\n  }\n  return n;\n};\n\n/**\n * Class for a number, string, boolean, null, or undefined.\n * @param {number|string|boolean|null|undefined} data Primitive value.\n * @param {!Interpreter} interpreter The JS Interpreter to bind to.\n * @constructor\n */\nInterpreter.Primitive = function(data, interpreter) {\n  var type = typeof data;\n  this.data = data;\n  this.type = type;\n  if (type == 'number') {\n    this.parent = interpreter.NUMBER;\n  } else if (type == 'string') {\n    this.parent = interpreter.STRING;\n  } else if (type == 'boolean') {\n    this.parent = interpreter.BOOLEAN;\n  }\n};\n\n/**\n * @type {number|string|boolean|null|undefined}\n */\nInterpreter.Primitive.prototype.data = undefined;\n\n/**\n * @type {string}\n */\nInterpreter.Primitive.prototype.type = 'undefined';\n\n/**\n * @type {Function}\n */\nInterpreter.Primitive.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Primitive.prototype.isPrimitive = true;\n\n/**\n * Convert this primitive into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Primitive.prototype.toBoolean = function() {\n  return Boolean(this.data);\n};\n\n/**\n * Convert this primitive into a number.\n * @return {number} Number value.\n */\nInterpreter.Primitive.prototype.toNumber = function() {\n  return Number(this.data);\n};\n\n/**\n * Convert this primitive into a string.\n * @return {string} String value.\n * @override\n */\nInterpreter.Primitive.prototype.toString = function() {\n  return String(this.data);\n};\n\n/**\n * Return the primitive value.\n * @return {number|string|boolean|null|undefined} Primitive value.\n * @override\n */\nInterpreter.Primitive.prototype.valueOf = function() {\n  return this.data;\n};\n\n/**\n * Create a new data object for a primitive.\n * @param {number|string|boolean|null|undefined|RegExp} data Data to\n *     encapsulate.\n * @return {!Interpreter.Primitive|!Interpreter.Object} New data object.\n */\nInterpreter.prototype.createPrimitive = function(data) {\n  // Reuse a predefined primitive constant if possible.\n  if (data === undefined) {\n    return this.UNDEFINED;\n  } else if (data === null) {\n    return this.NULL;\n  } else if (data === true) {\n    return this.TRUE;\n  } else if (data === false) {\n    return this.FALSE;\n  } else if (data === 0) {\n    return this.NUMBER_ZERO;\n  } else if (data === 1) {\n    return this.NUMBER_ONE;\n  } else if (data === '') {\n    return this.STRING_EMPTY;\n  } else if (data instanceof RegExp) {\n    return this.populateRegExp_(this.createObject(this.REGEXP), data);\n  }\n  return new Interpreter.Primitive(data, this);\n};\n\n/**\n * Class for an object.\n * @param {Interpreter.Object} parent Parent constructor function.\n * @constructor\n */\nInterpreter.Object = function(parent) {\n  this.notConfigurable = Object.create(null);\n  this.notEnumerable = Object.create(null);\n  this.notWritable = Object.create(null);\n  this.getter = Object.create(null);\n  this.setter = Object.create(null);\n  this.properties = Object.create(null);\n  this.parent = parent;\n};\n\n/**\n * @type {string}\n */\nInterpreter.Object.prototype.type = 'object';\n\n/**\n * @type {Interpreter.Object}\n */\nInterpreter.Object.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Object.prototype.isPrimitive = false;\n\n/**\n * @type {number|string|boolean|undefined|!RegExp}\n */\nInterpreter.Object.prototype.data = undefined;\n\n/**\n * Convert this object into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Object.prototype.toBoolean = function() {\n  return true;\n};\n\n/**\n * Convert this object into a number.\n * @return {number} Number value.\n */\nInterpreter.Object.prototype.toNumber = function() {\n  return Number(this.data === undefined ? this.toString() : this.data);\n};\n\n/**\n * Convert this object into a string.\n * @return {string} String value.\n * @override\n */\nInterpreter.Object.prototype.toString = function() {\n  return this.data === undefined ? ('[' + this.type + ']') : String(this.data);\n};\n\n/**\n * Return the object value.\n * @return {*} Value.\n * @override\n */\nInterpreter.Object.prototype.valueOf = function() {\n  return this.data === undefined ? this : this.data;\n};\n\n/**\n * Create a new data object.\n * @param {Interpreter.Object} parent Parent constructor function.\n * @return {!Interpreter.Object} New data object.\n */\nInterpreter.prototype.createObject = function(parent) {\n  var obj = new Interpreter.Object(parent);\n  // Functions have prototype objects.\n  if (this.isa(obj, this.FUNCTION)) {\n    obj.type = 'function';\n    this.setProperty(obj, 'prototype', this.createObject(this.OBJECT || null));\n  }\n  // Arrays have length.\n  if (this.isa(obj, this.ARRAY)) {\n    obj.length = 0;\n    obj.toString = function() {\n      var strs = [];\n      for (var i = 0; i < this.length; i++) {\n        var value = this.properties[i];\n        strs[i] = (!value || (value.isPrimitive && (value.data === null ||\n            value.data === undefined))) ? '' : value.toString();\n      }\n      return strs.join(',');\n    };\n  }\n  return obj;\n};\n\n/**\n * Initialize a pseudo regular expression object based on a native regular\n * expression object.\n * @param {!Interpreter.Object} pseudoRegexp The existing object to set.\n * @param {!RegExp} nativeRegexp The native regular expression.\n * @return {!Interpreter.Object} Newly populated regular expression object.\n * @private\n */\nInterpreter.prototype.populateRegExp_ = function(pseudoRegexp, nativeRegexp) {\n  pseudoRegexp.data = nativeRegexp;\n  // lastIndex is settable, all others are read-only attributes\n  this.setProperty(pseudoRegexp, 'lastIndex',\n      this.createPrimitive(nativeRegexp.lastIndex),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'source',\n      this.createPrimitive(nativeRegexp.source),\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'global',\n      this.createPrimitive(nativeRegexp.global),\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'ignoreCase',\n      this.createPrimitive(nativeRegexp.ignoreCase),\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'multiline',\n      this.createPrimitive(nativeRegexp.multiline),\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  // Override a couple of Object's conversion functions.\n  pseudoRegexp.toString = function() {return String(this.data);};\n  pseudoRegexp.valueOf = function() {return this.data;};\n  return pseudoRegexp;\n};\n\n/**\n * Create a new function.\n * @param {Object} node AST node defining the function.\n * @param {Object=} opt_scope Optional parent scope.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createFunction = function(node, opt_scope) {\n  var func = this.createObject(this.FUNCTION);\n  func.parentScope = opt_scope || this.getScope();\n  func.node = node;\n  this.setProperty(func, 'length',\n      this.createPrimitive(func.node.params.length),\n      Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Create a new native function.\n * @param {!Function} nativeFunc JavaScript function.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createNativeFunction = function(nativeFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.nativeFunc = nativeFunc;\n  this.setProperty(func, 'length', this.createPrimitive(nativeFunc.length),\n      Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Create a new native asynchronous function.\n * @param {!Function} asyncFunc JavaScript function.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createAsyncFunction = function(asyncFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.asyncFunc = asyncFunc;\n  this.setProperty(func, 'length', this.createPrimitive(asyncFunc.length),\n      Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Converts from a native JS object or value to a JS interpreter object.\n * Can handle JSON-style values.\n * @param {*} nativeObj The native JS object to be converted.\n * @return {!Interpreter.Object|!Interpreter.Primitive} The equivalent\n *     JS interpreter object.\n */\nInterpreter.prototype.nativeToPseudo = function(nativeObj) {\n  if (typeof nativeObj == 'boolean' ||\n      typeof nativeObj == 'number' ||\n      typeof nativeObj == 'string' ||\n      nativeObj === null || nativeObj === undefined ||\n      nativeObj instanceof RegExp) {\n    return this.createPrimitive(nativeObj);\n  }\n\n  if (nativeObj instanceof Function) {\n    var wrapper = (function(interpreter, nativeObj){\n      return function() {\n        return interpreter.nativeToPseudo(\n          nativeObj.apply(interpreter,\n            Array.prototype.slice.call(arguments)\n              .map(function(i) {\n                return interpreter.pseudoToNative(i);\n              })\n          )\n        );\n      };\n    })(this, nativeObj);\n    return this.createNativeFunction(wrapper);\n  }\n\n  var pseudoObj;\n  if (nativeObj instanceof Array) {  // Array.\n    pseudoObj = this.createObject(this.ARRAY);\n    for (var i = 0; i < nativeObj.length; i++) {\n      this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\n    }\n  } else {  // Object.\n    pseudoObj = this.createObject(this.OBJECT);\n    for (var key in nativeObj) {\n      this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\n    }\n  }\n  return pseudoObj;\n};\n\n/**\n * Converts from a JS interpreter object to native JS object.\n * Can handle JSON-style values.\n * @param {!Interpreter.Object|!Interpreter.Primitive} pseudoObj The JS\n *     interpreter object to be converted.\n * @return {*} The equivalent native JS object or value.\n */\nInterpreter.prototype.pseudoToNative = function(pseudoObj) {\n  if (pseudoObj.isPrimitive ||\n      this.isa(pseudoObj, this.NUMBER) ||\n      this.isa(pseudoObj, this.STRING) ||\n      this.isa(pseudoObj, this.BOOLEAN)) {\n    return pseudoObj.data;\n  }\n  var nativeObj;\n  if (this.isa(pseudoObj, this.ARRAY)) {  // Array.\n    nativeObj = [];\n    for (var i = 0; i < pseudoObj.length; i++) {\n      nativeObj[i] = this.pseudoToNative(pseudoObj.properties[i]);\n    }\n  } else {  // Object.\n    nativeObj = {};\n    for (var key in pseudoObj.properties) {\n      nativeObj[key] = this.pseudoToNative(pseudoObj.properties[key]);\n    }\n  }\n  return nativeObj;\n};\n\n/**\n * Fetch a property value from a data object.\n * @param {!Interpreter.Object|!Interpreter.Primitive} obj Data object.\n * @param {*} name Name of property.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} Property value\n *     (may be UNDEFINED), or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getProperty = function(obj, name) {\n  name = name.toString();\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot read property '\" + name + \"' of \" + obj);\n    return null;\n  }\n  // Special cases for magic length property.\n  if (this.isa(obj, this.STRING)) {\n    if (name == 'length') {\n      return this.createPrimitive(obj.data.length);\n    }\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return this.createPrimitive(obj.data[n]);\n    }\n  } else if (this.isa(obj, this.ARRAY) && name == 'length') {\n    return this.createPrimitive(obj.length);\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      var getter = obj.getter[name];\n      if (getter) {\n        // Flag this function as being a getter and thus needing immediate\n        // execution (rather than being the value of the property).\n        getter.isGetter = true;\n        return getter;\n      }\n      return obj.properties[name];\n    }\n    if (obj.parent && obj.parent.properties &&\n        obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return this.UNDEFINED;\n};\n\n/**\n * Does the named property exist on a data object.\n * @param {!Interpreter.Object|!Interpreter.Primitive} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if property exists.\n */\nInterpreter.prototype.hasProperty = function(obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive) {\n    throw TypeError('Primitive data type has no properties');\n  }\n  if (name == 'length' &&\n      (this.isa(obj, this.STRING) || this.isa(obj, this.ARRAY))) {\n    return true;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return true;\n    }\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      return true;\n    }\n    if (obj.parent && obj.parent.properties &&\n        obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return false;\n};\n\n/**\n * Set a property value on a data object.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @param {Interpreter.Object|Interpreter.Primitive} value\n *     New property value or null if getter/setter is described.\n * @param {Object=} opt_descriptor Optional descriptor object.\n * @return {!Interpreter.Object|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\nInterpreter.prototype.setProperty = function(obj, name, value, opt_descriptor) {\n  name = name.toString();\n  if (opt_descriptor && obj.notConfigurable[name]) {\n    this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\n  }\n  if (typeof value != 'object') {\n    throw Error('Failure to wrap a value: ' + value);\n  }\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot set property '\" + name + \"' of \" + obj);\n  }\n  if (opt_descriptor && (opt_descriptor.get || opt_descriptor.set) &&\n      (value || opt_descriptor.writable !== undefined)) {\n    this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' +\n        'Cannot both specify accessors and a value or writable attribute');\n  }\n  if (obj.isPrimitive) {\n    return;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (name == 'length' || (!isNaN(n) && n < obj.data.length)) {\n      // Can't set length or letters on Strings.\n      return;\n    }\n  }\n  if (this.isa(obj, this.ARRAY)) {\n    // Arrays have a magic length variable that is bound to the elements.\n    var i;\n    if (name == 'length') {\n      // Delete elements if length is smaller.\n      var newLength = this.arrayIndex(value.toNumber());\n      if (isNaN(newLength)) {\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\n      }\n      if (newLength < obj.length) {\n        for (i in obj.properties) {\n          i = this.arrayIndex(i);\n          if (!isNaN(i) && newLength <= i) {\n            delete obj.properties[i];\n          }\n        }\n      }\n      obj.length = newLength;\n      return;  // Don't set a real length property.\n    } else if (!isNaN(i = this.arrayIndex(name))) {\n      // Increase length if this index is larger.\n      obj.length = Math.max(obj.length, i + 1);\n    }\n  }\n  if (!obj.properties[name] && obj.preventExtensions) {\n    var scope = this.getScope();\n    if (scope.strict) {\n      this.throwException(this.TYPE_ERROR, 'Can\\'t add property ' + name +\n                          ', object is not extensible');\n    }\n    return;\n  }\n  if (opt_descriptor) {\n    // Define the property.\n    obj.properties[name] = value;\n    if (!opt_descriptor.configurable) {\n      obj.notConfigurable[name] = true;\n    }\n    var getter = opt_descriptor.get;\n    if (getter) {\n      obj.getter[name] = getter;\n    } else {\n      delete obj.getter[name];\n    }\n    var setter = opt_descriptor.set;\n    if (setter) {\n      obj.setter[name] = setter;\n    } else {\n      delete obj.setter[name];\n    }\n    var enumerable = opt_descriptor.enumerable || false;\n    if (enumerable) {\n      delete obj.notEnumerable[name];\n    } else {\n      obj.notEnumerable[name] = true;\n    }\n    if (getter || setter) {\n      delete obj.notWritable[name];\n      obj.properties[name] = this.UNDEFINED;\n    } else {\n      var writable = opt_descriptor.writable || false;\n      if (writable) {\n        delete obj.notWritable[name];\n      } else {\n        obj.notWritable[name] = true;\n      }\n    }\n  } else {\n    // Set the property.\n    // Determine if there is a setter anywhere in the history chain.\n    var parent = obj;\n    while (true) {\n      if (parent.setter && parent.setter[name]) {\n        return parent.setter[name];\n      }\n      if (parent.parent && parent.parent.properties &&\n          parent.parent.properties.prototype) {\n        parent = parent.parent.properties.prototype;\n      } else {\n        // No parent, reached the top.\n        break;\n      }\n    }\n    // No setter, simple assignment.\n    if (!obj.notWritable[name]) {\n      obj.properties[name] = value;\n    }\n  }\n};\n\n/**\n * Convenience method for adding a native function as a non-enumerable property\n * onto an object's prototype.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @param {!Function} wrapper Function object.\n */\nInterpreter.prototype.setNativeFunctionPrototype =\n    function(obj, name, wrapper) {\n  this.setProperty(obj.properties.prototype, name,\n      this.createNativeFunction(wrapper),\n      Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Delete a property value on a data object.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if deleted, false if undeletable.\n */\nInterpreter.prototype.deleteProperty = function(obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive || obj.notWritable[name]) {\n    return false;\n  }\n  if (name == 'length' && this.isa(obj, this.ARRAY)) {\n    return false;\n  }\n  return delete obj.properties[name];\n};\n\n/**\n * Returns the current scope from the stateStack.\n * @return {!Interpreter.Object} Current scope dictionary.\n */\nInterpreter.prototype.getScope = function() {\n  for (var i = 0; i < this.stateStack.length; i++) {\n    if (this.stateStack[i].scope) {\n      return this.stateStack[i].scope;\n    }\n  }\n  throw Error('No scope found.');\n};\n\n/**\n * Create a new scope dictionary.\n * @param {!Object} node AST node defining the scope container\n *     (e.g. a function).\n * @param {Interpreter.Object} parentScope Scope to link to.\n * @return {!Interpreter.Object} New scope.\n */\nInterpreter.prototype.createScope = function(node, parentScope) {\n  var scope = this.createObject(null);\n  scope.parentScope = parentScope;\n  if (!parentScope) {\n    this.initGlobalScope(scope);\n  }\n  this.populateScope_(node, scope);\n\n  // Determine if this scope starts with 'use strict'.\n  scope.strict = false;\n  if (parentScope && parentScope.strict) {\n    scope.strict = true;\n  } else {\n    var firstNode = node.body && node.body[0];\n    if (firstNode && firstNode.expression &&\n        firstNode.expression.type == 'Literal' &&\n        firstNode.expression.value == 'use strict') {\n      scope.strict = true;\n    }\n  }\n  return scope;\n};\n\n/**\n * Create a new special scope dictionary. Similar to createScope(), but\n * doesn't assume that the scope is for a function body. This is used for\n * the catch clause and with statement.\n * @param {!Interpreter.Object} parentScope Scope to link to.\n * @param {Interpreter.Object=} opt_scope Optional object to transform into\n *     scope.\n * @return {!Interpreter.Object} New scope.\n */\nInterpreter.prototype.createSpecialScope = function(parentScope, opt_scope) {\n  if (!parentScope) {\n    throw Error('parentScope required');\n  }\n  var scope = opt_scope || this.createObject(null);\n  scope.parentScope = parentScope;\n  scope.strict = parentScope.strict;\n  return scope;\n};\n\n\n/**\n * Retrieves a value from the scope chain.\n * @param {!Interpreter.Object|!Interpreter.Primitive} name Name of variable.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} The value\n *     or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getValueFromScope = function(name) {\n  var scope = this.getScope();\n  var nameStr = name.toString();\n  while (scope) {\n    if (nameStr in scope.properties) {\n      return scope.properties[nameStr];\n    }\n    scope = scope.parentScope;\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n  return null;\n};\n\n/**\n * Sets a value to the current scope.\n * @param {!Interpreter.Object|!Interpreter.Primitive} name Name of variable.\n * @param {!Interpreter.Object|!Interpreter.Primitive} value Value.\n */\nInterpreter.prototype.setValueToScope = function(name, value) {\n  var scope = this.getScope();\n  var strict = scope.strict;\n  var nameStr = name.toString();\n  while (scope) {\n    if ((nameStr in scope.properties) || (!strict && !scope.parentScope)) {\n      if (!scope.notWritable[nameStr]) {\n        scope.properties[nameStr] = value;\n      }\n      return;\n    }\n    scope = scope.parentScope;\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n};\n\n/**\n * Create a new scope for the given node.\n * @param {!Object} node AST node (program or function).\n * @param {!Interpreter.Object} scope Scope dictionary to populate.\n * @private\n */\nInterpreter.prototype.populateScope_ = function(node, scope) {\n  if (node.type == 'VariableDeclaration') {\n    for (var i = 0; i < node.declarations.length; i++) {\n      this.setProperty(scope, node.declarations[i].id.name, this.UNDEFINED);\n    }\n  } else if (node.type == 'FunctionDeclaration') {\n    this.setProperty(scope, node.id.name, this.createFunction(node, scope));\n    return;  // Do not recurse into function.\n  } else if (node.type == 'FunctionExpression') {\n    return;  // Do not recurse into function.\n  }\n  var parent = node.constructor;\n  for (var name in node) {\n    var prop = node[name];\n    if (prop && typeof prop == 'object') {\n      if (prop instanceof Array) {\n        for (var i = 0; i < prop.length; i++) {\n          if (prop[i] && prop[i].constructor == parent) {\n            this.populateScope_(prop[i], scope);\n          }\n        }\n      } else {\n        if (prop.constructor == parent) {\n          this.populateScope_(prop, scope);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Remove start and end values from AST.\n * Used to remove highlighting from polyfills.\n * @param {!Object} node AST node.\n * @private\n */\nInterpreter.prototype.stripLocations_ = function(node) {\n  delete node.start;\n  delete node.end;\n  for (var name in node) {\n    if (node.hasOwnProperty(name)) {\n      var prop = node[name];\n      if (prop && typeof prop == 'object') {\n        this.stripLocations_(prop);\n      }\n    }\n  }\n};\n\n/**\n * Gets a value from the scope chain or from an object property.\n * @param {!Interpreter.Object|!Interpreter.Primitive|!Array} left\n *     Name of variable or object/propname tuple.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} Value\n *     or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getValue = function(left) {\n  if (left instanceof Array) {\n    var obj = left[0];\n    var prop = left[1];\n    return this.getProperty(obj, prop);\n  } else {\n    return this.getValueFromScope(left);\n  }\n};\n\n/**\n * Sets a value to the scope chain or to an object property.\n * @param {!Interpreter.Object|!Interpreter.Primitive|!Array} left\n *     Name of variable or object/propname tuple.\n * @param {!Interpreter.Object|!Interpreter.Primitive} value Value.\n * @return {!Interpreter.Object|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\nInterpreter.prototype.setValue = function(left, value) {\n  if (left instanceof Array) {\n    var obj = left[0];\n    var prop = left[1];\n    return this.setProperty(obj, prop, value);\n  } else {\n    this.setValueToScope(left, value);\n    return undefined;\n  }\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.  Can be called with either an error class and a message, or\n * with an actual object to be thrown.\n * @param {!Interpreter.Object} errorClass Type of error (if message is\n *   provided) or the value to throw (if no message).\n * @param {string=} opt_message Message being thrown.\n */\nInterpreter.prototype.throwException = function(errorClass, opt_message) {\n  if (this.stateStack[0].interpreter) {\n    // This is the wrong interpreter, we are spinning on an eval.\n    try {\n      this.stateStack[0].interpreter.throwException(errorClass, opt_message);\n      return;\n    } catch (e) {\n      // The eval threw an error and did not catch it.\n      // Continue to see if this level can catch it.\n    }\n  }\n  if (opt_message === undefined) {\n    var error = errorClass;\n  } else {\n    var error = this.createObject(errorClass);\n    this.setProperty(error, 'message', this.createPrimitive(opt_message),\n        Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n  this.executeException(error);\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.\n * @param {!Interpreter.Object} error Error object to execute.\n */\nInterpreter.prototype.executeException = function(error) {\n  // Search for a try statement.\n  do {\n    this.stateStack.shift();\n    var state = this.stateStack[0];\n    if (state.node.type == 'TryStatement') {\n      state.throwValue = error;\n      return;\n    }\n  } while (state && state.node.type != 'Program');\n\n  // Throw a real error.\n  var realError;\n  if (this.isa(error, this.ERROR)) {\n    var errorTable = {\n      'EvalError': EvalError,\n      'RangeError': RangeError,\n      'ReferenceError': ReferenceError,\n      'SyntaxError': SyntaxError,\n      'TypeError': TypeError,\n      'URIError': URIError\n    };\n    var name = this.getProperty(error, 'name').toString();\n    var message = this.getProperty(error, 'message').valueOf();\n    var type = errorTable[name] || Error;\n    realError = type(message);\n  } else {\n    realError = error.toString();\n  }\n  throw realError;\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Functions to handle each node type.\n///////////////////////////////////////////////////////////////////////////////\n\nInterpreter.prototype['stepArrayExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (!state.array) {\n    state.array = this.createObject(this.ARRAY);\n  } else if (state.value) {\n    this.setProperty(state.array, n - 1, state.value);\n  }\n  if (n < node.elements.length) {\n    state.n = n + 1;\n    if (node.elements[n]) {\n      this.stateStack.unshift({node: node.elements[n]});\n    } else {\n      // [0, 1, , 3][2] -> undefined\n      // Missing elements are not defined, they aren't undefined.\n      state.value = undefined;\n    }\n  } else {\n    state.array.length = state.n || 0;\n    this.stateStack.shift();\n    this.stateStack[0].value = state.array;\n  }\n};\n\nInterpreter.prototype['stepAssignmentExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneLeft) {\n    state.doneLeft = true;\n    this.stateStack.unshift({node: node.left, components: true});\n    return;\n  }\n  if (!state.doneRight) {\n    if (!state.leftSide) {\n      state.leftSide = state.value;\n    }\n    if (state.doneGetter_) {\n      state.leftValue = state.value;\n    }\n    if (!state.doneGetter_ && node.operator != '=') {\n      state.leftValue = this.getValue(state.leftSide);\n      if (state.leftValue.isGetter) {\n        // Clear the getter flag and call the getter function.\n        state.leftValue.isGetter = false;\n        state.doneGetter_ = true;\n        this.stateStack.unshift({\n          node: {type: 'CallExpression'},\n          doneCallee_: true,\n          funcThis_: state.leftSide[0],\n          func_: state.leftValue,\n          doneArgs_: true,\n          arguments: []\n        });\n        return;\n      }\n    }\n    state.doneRight = true;\n    this.stateStack.unshift({node: node.right});\n    return;\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    this.stateStack.shift();\n    this.stateStack[0].value = state.doneSetter_;\n    return;\n  }\n  var rightSide = state.value;\n  var value;\n  if (node.operator == '=') {\n    value = rightSide;\n  } else {\n    var rightValue = rightSide;\n    var leftNumber = state.leftValue.toNumber();\n    var rightNumber = rightValue.toNumber();\n    if (node.operator == '+=') {\n      var left, right;\n      if (state.leftValue.type == 'string' || rightValue.type == 'string') {\n        left = state.leftValue.toString();\n        right = rightValue.toString();\n      } else {\n        left = leftNumber;\n        right = rightNumber;\n      }\n      value = left + right;\n    } else if (node.operator == '-=') {\n      value = leftNumber - rightNumber;\n    } else if (node.operator == '*=') {\n      value = leftNumber * rightNumber;\n    } else if (node.operator == '/=') {\n      value = leftNumber / rightNumber;\n    } else if (node.operator == '%=') {\n      value = leftNumber % rightNumber;\n    } else if (node.operator == '<<=') {\n      value = leftNumber << rightNumber;\n    } else if (node.operator == '>>=') {\n      value = leftNumber >> rightNumber;\n    } else if (node.operator == '>>>=') {\n      value = leftNumber >>> rightNumber;\n    } else if (node.operator == '&=') {\n      value = leftNumber & rightNumber;\n    } else if (node.operator == '^=') {\n      value = leftNumber ^ rightNumber;\n    } else if (node.operator == '|=') {\n      value = leftNumber | rightNumber;\n    } else {\n      throw SyntaxError('Unknown assignment expression: ' + node.operator);\n    }\n    value = this.createPrimitive(value);\n  }\n  var setter = this.setValue(state.leftSide, value);\n  if (setter) {\n    state.doneSetter_ = value;\n    this.stateStack.unshift({\n      node: {type: 'CallExpression'},\n      doneCallee_: true,\n      funcThis_: state.leftSide[0],\n      func_: setter,\n      doneArgs_: true,\n      arguments: [value]\n    });\n    return;\n  }\n  // Return if no setter function.\n  this.stateStack.shift();\n  this.stateStack[0].value = value;\n};\n\nInterpreter.prototype['stepBinaryExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneLeft) {\n    state.doneLeft = true;\n    this.stateStack.unshift({node: node.left});\n    return;\n  }\n  if (!state.doneRight) {\n    state.doneRight = true;\n    state.leftValue = state.value;\n    this.stateStack.unshift({node: node.right});\n    return;\n  }\n  this.stateStack.shift();\n  var leftSide = state.leftValue;\n  var rightSide = state.value;\n  var value;\n  var comp = this.comp(leftSide, rightSide);\n  if (node.operator == '==' || node.operator == '!=') {\n    if (leftSide.isPrimitive && rightSide.isPrimitive) {\n      value = leftSide.data == rightSide.data;\n    } else {\n      value = comp === 0;\n    }\n    if (node.operator == '!=') {\n      value = !value;\n    }\n  } else if (node.operator == '===' || node.operator == '!==') {\n    if (leftSide.isPrimitive && rightSide.isPrimitive) {\n      value = leftSide.data === rightSide.data;\n    } else {\n      value = leftSide === rightSide;\n    }\n    if (node.operator == '!==') {\n      value = !value;\n    }\n  } else if (node.operator == '>') {\n    value = comp == 1;\n  } else if (node.operator == '>=') {\n    value = comp == 1 || comp === 0;\n  } else if (node.operator == '<') {\n    value = comp == -1;\n  } else if (node.operator == '<=') {\n    value = comp == -1 || comp === 0;\n  } else if (node.operator == '+') {\n    var leftValue =\n        leftSide.isPrimitive ? leftSide.data : leftSide.toString();\n    var rightValue =\n        rightSide.isPrimitive ? rightSide.data : rightSide.toString();\n    value = leftValue + rightValue;\n  } else if (node.operator == 'in') {\n    value = this.hasProperty(rightSide, leftSide);\n  } else if (node.operator == 'instanceof') {\n    if (!this.isa(rightSide, this.FUNCTION)) {\n      this.throwException(this.TYPE_ERROR,\n          'Expecting a function in instanceof check');\n    }\n    value = this.isa(leftSide, rightSide);\n  } else {\n    var leftValue = leftSide.toNumber();\n    var rightValue = rightSide.toNumber();\n    if (node.operator == '-') {\n      value = leftValue - rightValue;\n    } else if (node.operator == '*') {\n      value = leftValue * rightValue;\n    } else if (node.operator == '/') {\n      value = leftValue / rightValue;\n    } else if (node.operator == '%') {\n      value = leftValue % rightValue;\n    } else if (node.operator == '&') {\n      value = leftValue & rightValue;\n    } else if (node.operator == '|') {\n      value = leftValue | rightValue;\n    } else if (node.operator == '^') {\n      value = leftValue ^ rightValue;\n    } else if (node.operator == '<<') {\n      value = leftValue << rightValue;\n    } else if (node.operator == '>>') {\n      value = leftValue >> rightValue;\n    } else if (node.operator == '>>>') {\n      value = leftValue >>> rightValue;\n    } else {\n      throw SyntaxError('Unknown binary operator: ' + node.operator);\n    }\n  }\n  this.stateStack[0].value = this.createPrimitive(value);\n};\n\nInterpreter.prototype['stepBlockStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.body[n]) {\n    state.done = false;\n    state.n_ = n + 1;\n    this.stateStack.unshift({node: node.body[n]});\n  } else {\n    state.done = true;\n    if (state.node.type != 'Program') {\n      // Leave the root scope on the tree in case the program is appended to.\n      this.stateStack.shift();\n    }\n  }\n};\n\nInterpreter.prototype['stepBreakStatement'] = function() {\n  var state = this.stateStack.shift();\n  var node = state.node;\n  var label = null;\n  if (node.label) {\n    label = node.label.name;\n  }\n  state = this.stateStack.shift();\n  while (state &&\n         state.node.type != 'CallExpression' &&\n         state.node.type != 'NewExpression') {\n    if (label ? label == state.label : (state.isLoop || state.isSwitch)) {\n      return;\n    }\n    state = this.stateStack.shift();\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal break statement');\n};\n\nInterpreter.prototype['stepCallExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneCallee_) {\n    state.doneCallee_ = true;\n    this.stateStack.unshift({node: node.callee, components: true});\n    return;\n  }\n  if (!state.func_) {\n    // Determine value of the function.\n    if (state.value.type == 'function') {\n      state.func_ = state.value;\n    } else {\n      if (state.value.length) {\n        state.member_ = state.value[0];\n      }\n      state.func_ = this.getValue(state.value);\n      if (!state.func_) {\n        return;  // Thrown error, but trapped.\n      } else if (state.func_.type != 'function') {\n        this.throwException(this.TYPE_ERROR,\n            (state.value && state.value.type) + ' is not a function');\n        return;\n      }\n    }\n    // Determine value of 'this' in function.\n    if (state.node.type == 'NewExpression') {\n      state.funcThis_ = this.createObject(state.func_);\n      state.isConstructor_ = true;\n    } else if (state.func_.boundThis_) {\n      state.funcThis_ = state.func_.boundThis_;\n    } else if (state.value.length) {\n      state.funcThis_ = state.value[0];\n    } else {\n      state.funcThis_ =\n          this.stateStack[this.stateStack.length - 1].thisExpression;\n    }\n    if (state.func_.boundArgs_) {\n      state.arguments = state.func_.boundArgs_.concat();\n    } else {\n      state.arguments = [];\n    }\n    state.n_ = 0;\n  }\n  if (!state.doneArgs_) {\n    if (state.n_ != 0) {\n      state.arguments.push(state.value);\n    }\n    if (node.arguments[state.n_]) {\n      this.stateStack.unshift({node: node.arguments[state.n_]});\n      state.n_++;\n      return;\n    }\n    state.doneArgs_ = true;\n  }\n  if (!state.doneExec_) {\n    state.doneExec_ = true;\n    if (state.func_.node) {\n      var scope =\n          this.createScope(state.func_.node.body, state.func_.parentScope);\n      // Add all arguments.\n      for (var i = 0; i < state.func_.node.params.length; i++) {\n        var paramName = this.createPrimitive(state.func_.node.params[i].name);\n        var paramValue = state.arguments.length > i ? state.arguments[i] :\n            this.UNDEFINED;\n        this.setProperty(scope, paramName, paramValue);\n      }\n      // Build arguments variable.\n      var argsList = this.createObject(this.ARRAY);\n      for (var i = 0; i < state.arguments.length; i++) {\n        this.setProperty(argsList, this.createPrimitive(i),\n                         state.arguments[i]);\n      }\n      this.setProperty(scope, 'arguments', argsList);\n      var funcState = {\n        node: state.func_.node.body,\n        scope: scope,\n        thisExpression: state.funcThis_\n      };\n      this.stateStack.unshift(funcState);\n      state.value = this.UNDEFINED;  // Default value if no explicit return.\n    } else if (state.func_.nativeFunc) {\n      state.value = state.func_.nativeFunc.apply(state.funcThis_,\n                                                 state.arguments);\n    } else if (state.func_.asyncFunc) {\n      var thisInterpreter = this;\n      var callback = function(value) {\n        state.value = value || thisInterpreter.UNDEFINED;\n        thisInterpreter.paused_ = false;\n      };\n      var argsWithCallback = state.arguments.concat(callback);\n      state.func_.asyncFunc.apply(state.funcThis_, argsWithCallback);\n      this.paused_ = true;\n      return;\n    } else if (state.func_.eval) {\n      var code = state.arguments[0];\n      if (!code) {\n        state.value = this.UNDEFINED;\n      } else if (!code.isPrimitive) {\n        // JS does not parse String objects:\n        // eval(new String('1 + 1')) -> '1 + 1'\n        state.value = code;\n      } else {\n        var evalInterpreter = new Interpreter(code.toString());\n        evalInterpreter.stateStack[0].scope = this.getScope();\n        state = {\n          node: {type: 'Eval_'},\n          interpreter: evalInterpreter\n        };\n        this.stateStack.unshift(state);\n      }\n    } else {\n      throw TypeError('function not a function (huh?)');\n    }\n  } else {\n    // Execution complete.  Put the return value on the stack.\n    this.stateStack.shift();\n    if (state.isConstructor_ && state.value.type !== 'object') {\n      this.stateStack[0].value = state.funcThis_;\n    } else {\n      this.stateStack[0].value = state.value;\n    }\n  }\n};\n\nInterpreter.prototype['stepCatchClause'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneBody) {\n    state.doneBody = true;\n    var scope;\n    if (node.param) {\n      scope = this.createSpecialScope(this.getScope());\n      // Add the argument.\n      var paramName = this.createPrimitive(node.param.name);\n      this.setProperty(scope, paramName, state.throwValue);\n    }\n    this.stateStack.unshift({node: node.body, scope: scope});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepConditionalExpression'] = function() {\n  var state = this.stateStack[0];\n  if (!state.done) {\n    if (!state.test) {\n      state.test = true;\n      this.stateStack.unshift({node: state.node.test});\n    } else {\n      state.done = true;\n      if (state.value.toBoolean() && state.node.consequent) {\n        this.stateStack.unshift({node: state.node.consequent});\n      } else if (!state.value.toBoolean() && state.node.alternate) {\n        this.stateStack.unshift({node: state.node.alternate});\n      }\n    }\n  } else {\n    this.stateStack.shift();\n    if (state.node.type == 'ConditionalExpression') {\n      this.stateStack[0].value = state.value;\n    }\n  }\n};\n\nInterpreter.prototype['stepContinueStatement'] = function() {\n  var node = this.stateStack[0].node;\n  var label = null;\n  if (node.label) {\n    label = node.label.name;\n  }\n  var state = this.stateStack[0];\n  while (state &&\n         state.node.type != 'CallExpression' &&\n         state.node.type != 'NewExpression') {\n    if (state.isLoop) {\n      if (!label || (label == state.label)) {\n        return;\n      }\n    }\n    this.stateStack.shift();\n    state = this.stateStack[0];\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal continue statement');\n};\n\nInterpreter.prototype['stepDoWhileStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  if (state.node.type == 'DoWhileStatement' && state.test === undefined) {\n    // First iteration of do/while executes without checking test.\n    state.value = this.TRUE;\n    state.test = true;\n  }\n  if (!state.test) {\n    state.test = true;\n    this.stateStack.unshift({node: state.node.test});\n  } else {\n    state.test = false;\n    if (!state.value.toBoolean()) {\n      this.stateStack.shift();\n    } else if (state.node.body) {\n      this.stateStack.unshift({node: state.node.body});\n    }\n  }\n};\n\nInterpreter.prototype['stepEmptyStatement'] = function() {\n  this.stateStack.shift();\n};\n\nInterpreter.prototype['stepEval_'] = function() {\n  var state = this.stateStack[0];\n  if (!state.interpreter.step()) {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.interpreter.value || this.UNDEFINED;\n  }\n};\n\nInterpreter.prototype['stepExpressionStatement'] = function() {\n  var state = this.stateStack[0];\n  if (!state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: state.node.expression});\n  } else {\n    this.stateStack.shift();\n    // Save this value to the interpreter for use as a return value if\n    // this code is inside an eval function.\n    this.value = state.value;\n  }\n};\n\nInterpreter.prototype['stepForInStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  var node = state.node;\n  if (!state.doneVariable_) {\n    state.doneVariable_ = true;\n    var left = node.left;\n    if (left.type == 'VariableDeclaration') {\n      // Inline variable declaration: for (var x in y)\n      left = left.declarations[0].id;\n    }\n    this.stateStack.unshift({node: left, components: true});\n    return;\n  }\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    state.variable = state.value;\n    this.stateStack.unshift({node: node.right});\n    return;\n  }\n  if (typeof state.iterator == 'undefined') {\n    // First iteration.\n    state.object = state.value;\n    state.iterator = 0;\n  }\n  var name = null;\n  done: do {\n    var i = state.iterator;\n    for (var prop in state.object.properties) {\n      if (state.object.notEnumerable[prop]) {\n        continue;\n      }\n      if (i == 0) {\n        name = prop;\n        break done;\n      }\n      i--;\n    }\n    state.object = state.object.parent &&\n        state.object.parent.properties.prototype;\n    state.iterator = 0;\n  } while (state.object);\n  state.iterator++;\n  if (name === null) {\n    this.stateStack.shift();\n  } else {\n    this.setValueToScope(state.variable, this.createPrimitive(name));\n    if (node.body) {\n      this.stateStack.unshift({node: node.body});\n    }\n  }\n};\n\nInterpreter.prototype['stepForStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  var node = state.node;\n  var mode = state.mode || 0;\n  if (mode == 0) {\n    state.mode = 1;\n    if (node.init) {\n      this.stateStack.unshift({node: node.init});\n    }\n  } else if (mode == 1) {\n    state.mode = 2;\n    if (node.test) {\n      this.stateStack.unshift({node: node.test});\n    }\n  } else if (mode == 2) {\n    state.mode = 3;\n    if (node.test && state.value && !state.value.toBoolean()) {\n      // Loop complete.  Bail out.\n      this.stateStack.shift();\n    } else if (node.body) {\n      this.stateStack.unshift({node: node.body});\n    }\n  } else if (mode == 3) {\n    state.mode = 1;\n    if (node.update) {\n      this.stateStack.unshift({node: node.update});\n    }\n  }\n};\n\nInterpreter.prototype['stepFunctionDeclaration'] = function() {\n  this.stateStack.shift();\n};\n\nInterpreter.prototype['stepFunctionExpression'] = function() {\n  var state = this.stateStack.shift();\n  this.stateStack[0].value = this.createFunction(state.node);\n};\n\nInterpreter.prototype['stepIdentifier'] = function() {\n  var state = this.stateStack.shift();\n  var name = this.createPrimitive(state.node.name);\n  this.stateStack[0].value =\n      state.components ? name : this.getValueFromScope(name);\n};\n\nInterpreter.prototype['stepIfStatement'] =\n    Interpreter.prototype['stepConditionalExpression'];\n\nInterpreter.prototype['stepLabeledStatement'] = function() {\n  // No need to hit this node again on the way back up the stack.\n  var state = this.stateStack.shift();\n  this.stateStack.unshift({node: state.node.body,\n                          label: state.node.label.name});\n};\n\nInterpreter.prototype['stepLiteral'] = function() {\n  var state = this.stateStack.shift();\n  this.stateStack[0].value = this.createPrimitive(state.node.value);\n};\n\nInterpreter.prototype['stepLogicalExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.operator != '&&' && node.operator != '||') {\n    throw SyntaxError('Unknown logical operator: ' + node.operator);\n  }\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.unshift({node: node.left});\n  } else if (!state.doneRight_) {\n    if ((node.operator == '&&' && !state.value.toBoolean()) ||\n        (node.operator == '||' && state.value.toBoolean())) {\n      // Shortcut evaluation.\n      this.stateStack.shift();\n      this.stateStack[0].value = state.value;\n    } else {\n      state.doneRight_ = true;\n      this.stateStack.unshift({node: node.right});\n    }\n  } else {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepMemberExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    this.stateStack.unshift({node: node.object});\n  } else if (!state.doneProperty_) {\n    state.doneProperty_ = true;\n    state.object = state.value;\n    this.stateStack.unshift({\n      node: node.property,\n      components: !node.computed\n    });\n  } else {\n    this.stateStack.shift();\n    if (state.components) {\n      this.stateStack[0].value = [state.object, state.value];\n    } else {\n      var value = this.getProperty(state.object, state.value);\n      if (!value) {\n        this.stateStack.unshift({});\n        this.throwException(this.TYPE_ERROR,\n            \"Cannot read property '\" + state.value + \"' of \" +\n            state.object.toString());\n        return;\n      }\n      if (value.isGetter) {\n        // Clear the getter flag and call the getter function.\n        value.isGetter = false;\n        this.stateStack.unshift({\n          node: {type: 'CallExpression'},\n          doneCallee_: true,\n          funcThis_: state.object,\n          func_: value,\n          doneArgs_: true,\n          arguments: []\n        });\n      } else {\n        this.stateStack[0].value = value;\n      }\n    }\n  }\n};\n\nInterpreter.prototype['stepNewExpression'] =\n    Interpreter.prototype['stepCallExpression'];\n\nInterpreter.prototype['stepObjectExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var valueToggle = state.valueToggle;\n  var n = state.n || 0;\n  if (!state.object) {\n    state.object = this.createObject(this.OBJECT);\n    state.properties = Object.create(null);\n  } else {\n    if (valueToggle) {\n      state.key = state.value;\n    } else {\n      if (!state.properties[state.key]) {\n        // Create temp object to collect value, getter, and/or setter.\n        state.properties[state.key] = {};\n      }\n      state.properties[state.key][state.kind] = state.value;\n    }\n  }\n  if (node.properties[n]) {\n    if (valueToggle) {\n      state.n = n + 1;\n      this.stateStack.unshift({node: node.properties[n].value});\n    } else {\n      state.kind = node.properties[n].kind;\n      this.stateStack.unshift({node: node.properties[n].key, components: true});\n    }\n    state.valueToggle = !valueToggle;\n  } else {\n    for (var key in state.properties) {\n      var kinds = state.properties[key];\n      if ('get' in kinds || 'set' in kinds) {\n        // Set a property with a getter or setter.\n        var descriptor = {\n          configurable: true,\n          enumerable: true,\n          get: kinds['get'],\n          set: kinds['set']\n        };\n        this.setProperty(state.object, key, null, descriptor);\n      } else {\n        // Set a normal property with a value.\n        this.setProperty(state.object, key, kinds['init']);\n      }\n    }\n    this.stateStack.shift();\n    this.stateStack[0].value = state.object;\n  }\n};\n\nInterpreter.prototype['stepProgram'] =\n    Interpreter.prototype['stepBlockStatement'];\n\nInterpreter.prototype['stepReturnStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.argument && !state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: node.argument});\n  } else {\n    var value = state.value || this.UNDEFINED;\n    do {\n      this.stateStack.shift();\n      if (this.stateStack.length == 0) {\n        // Syntax error, do not allow this error to be trapped.\n        throw SyntaxError('Illegal return statement');\n      }\n      state = this.stateStack[0];\n    } while (state.node.type != 'CallExpression' &&\n             state.node.type != 'NewExpression');\n    state.value = value;\n  }\n};\n\nInterpreter.prototype['stepSequenceExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (node.expressions[n]) {\n    state.n = n + 1;\n    this.stateStack.unshift({node: node.expressions[n]});\n  } else {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepSwitchStatement'] = function() {\n  var state = this.stateStack[0];\n  state.checked = state.checked || [];\n  state.isSwitch = true;\n\n  if (!state.test) {\n    state.test = true;\n    this.stateStack.unshift({node: state.node.discriminant});\n    return;\n  }\n  if (!state.switchValue) {\n    // Preserve switch value between case tests.\n    state.switchValue = state.value;\n  }\n\n  var index = state.index || 0;\n  var currentCase = state.node.cases[index];\n  if (currentCase) {\n    if (!state.done && !state.checked[index] && currentCase.test) {\n      state.checked[index] = true;\n      this.stateStack.unshift({node: currentCase.test});\n      return;\n    }\n    // Test on the default case will be null.\n    if (state.done || !currentCase.test ||\n        this.comp(state.value, state.switchValue) == 0) {\n      state.done = true;\n      var n = state.n || 0;\n      if (currentCase.consequent[n]) {\n        this.stateStack.unshift({node: currentCase.consequent[n]});\n        state.n = n + 1;\n        return;\n      }\n    }\n    state.n = 0;\n    state.index = index + 1;\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepThisExpression'] = function() {\n  this.stateStack.shift();\n  for (var i = 0; i < this.stateStack.length; i++) {\n    if (this.stateStack[i].thisExpression) {\n      this.stateStack[0].value = this.stateStack[i].thisExpression;\n      return;\n    }\n  }\n  throw Error('No this expression found.');\n};\n\nInterpreter.prototype['stepThrowStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.argument) {\n    state.argument = true;\n    this.stateStack.unshift({node: node.argument});\n  } else {\n    this.throwException(state.value);\n  }\n};\n\nInterpreter.prototype['stepTryStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneBlock) {\n    state.doneBlock = true;\n    this.stateStack.unshift({node: node.block});\n  } else if (state.throwValue && !state.doneHandler && node.handler) {\n    state.doneHandler = true;\n    this.stateStack.unshift({node: node.handler, throwValue: state.throwValue});\n    state.throwValue = null;  // This error has been handled, don't rethrow.\n  } else if (!state.doneFinalizer && node.finalizer) {\n    state.doneFinalizer = true;\n    this.stateStack.unshift({node: node.finalizer});\n  } else if (state.throwValue) {\n    // There was no catch handler, or the catch/finally threw an error.\n    // Throw the error up to a higher try.\n    this.executeException(state.throwValue);\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepUnaryExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.done) {\n    state.done = true;\n    var nextState = {node: node.argument};\n    if (node.operator == 'delete' || node.operator == 'typeof') {\n      nextState.components = true;\n    }\n    this.stateStack.unshift(nextState);\n    return;\n  }\n  this.stateStack.shift();\n  var value;\n  if (node.operator == '-') {\n    value = -state.value.toNumber();\n  } else if (node.operator == '+') {\n    value = state.value.toNumber();\n  } else if (node.operator == '!') {\n    value = !state.value.toBoolean();\n  } else if (node.operator == '~') {\n    value = ~state.value.toNumber();\n  } else if (node.operator == 'delete' || node.operator == 'typeof') {\n    if (state.value.length) {\n      var obj = state.value[0];\n      var name = state.value[1];\n    } else {\n      var obj = this.getScope();\n      var name = state.value;\n    }\n    if (node.operator == 'delete') {\n      value = this.deleteProperty(obj, name);\n    } else {\n      value = this.getProperty(obj, name).type;\n    }\n  } else if (node.operator == 'void') {\n    value = undefined;\n  } else {\n    throw SyntaxError('Unknown unary operator: ' + node.operator);\n  }\n  this.stateStack[0].value = this.createPrimitive(value);\n};\n\nInterpreter.prototype['stepUpdateExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneLeft) {\n    state.doneLeft = true;\n    this.stateStack.unshift({node: node.argument, components: true});\n    return;\n  }\n  if (!state.leftSide) {\n    state.leftSide = state.value;\n  }\n  if (state.doneGetter_) {\n    state.leftValue = state.value;\n  }\n  if (!state.doneGetter_) {\n    state.leftValue = this.getValue(state.leftSide);\n    if (!state.leftValue) {\n      return;  // Thrown error, but trapped.\n    }\n    if (state.leftValue.isGetter) {\n      // Clear the getter flag and call the getter function.\n      state.leftValue.isGetter = false;\n      state.doneGetter_ = true;\n      this.stateStack.unshift({\n        node: {type: 'CallExpression'},\n        doneCallee_: true,\n        funcThis_: state.leftSide[0],\n        func_: state.leftValue,\n        doneArgs_: true,\n        arguments: []\n      });\n      return;\n    }\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    this.stateStack.shift();\n    this.stateStack[0].value = state.doneSetter_;\n    return;\n  }\n  var leftValue = state.leftValue.toNumber();\n  var changeValue;\n  if (node.operator == '++') {\n    changeValue = this.createPrimitive(leftValue + 1);\n  } else if (node.operator == '--') {\n    changeValue = this.createPrimitive(leftValue - 1);\n  } else {\n    throw SyntaxError('Unknown update expression: ' + node.operator);\n  }\n  var returnValue = node.prefix ?\n      changeValue : this.createPrimitive(leftValue);\n  var setter = this.setValue(state.leftSide, changeValue);\n  if (setter) {\n    state.doneSetter_ = returnValue;\n    this.stateStack.unshift({\n      node: {type: 'CallExpression'},\n      doneCallee_: true,\n      funcThis_: state.leftSide[0],\n      func_: setter,\n      doneArgs_: true,\n      arguments: [changeValue]\n    });\n    return;\n  }\n  // Return if no setter function.\n  this.stateStack.shift();\n  this.stateStack[0].value = returnValue;\n};\n\nInterpreter.prototype['stepVariableDeclaration'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (node.declarations[n]) {\n    state.n = n + 1;\n    this.stateStack.unshift({node: node.declarations[n]});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepVariableDeclarator'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.init && !state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: node.init});\n    return;\n  }\n  if (node.init) {\n    // This setValue call never needs to deal with calling a setter function.\n    this.setValue(this.createPrimitive(node.id.name), state.value);\n  }\n  this.stateStack.shift();\n};\n\nInterpreter.prototype['stepWithStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneObject) {\n    state.doneObject = true;\n    this.stateStack.unshift({node: node.object});\n  } else if (!state.doneBody) {\n    state.doneBody = true;\n    var scope = this.createSpecialScope(this.getScope(), state.value);\n    this.stateStack.unshift({node: node.body, scope: scope});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepWhileStatement'] =\n    Interpreter.prototype['stepDoWhileStatement'];\n\nmodule.exports = Interpreter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/interpreter.js\n// module id = 0\n// module chunks = 0","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\"\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName)\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n    this.skipLineComment(2)\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^\\']|\\.)*)'|\"((?:[^\\\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && (this.strict || node.body.kind != \"var\") ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement == null)\n    isStatement = this.type == tt.name\n  if (isStatement)\n    node.id = this.parseIdent()\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  if (!isStatement && this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n  if (isStatement == null) isStatement = this.type === tt.name\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, null, false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, null)\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (Object.prototype.hasOwnProperty.call(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\"\n    || this.type.keyword === \"const\"\n    || this.type.keyword === \"class\"\n    || this.type.keyword === \"function\"\n    || this.isLet()\n    || this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, true)\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, true)\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp$2.checkLVal = function(expr, isBinding, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    refDestructuringErrors.parenthesizedAssign = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.labels = oldLabels\n  }\n\n  if (oldStrict || useStrict) {\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node)\n    this.strict = oldStrict\n  } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {\n    this.checkParams(node)\n  }\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$5 = Parser.prototype\n\npp$5.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$5.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$5.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$5.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true)\n}\n\nvar pp$6 = Parser.prototype\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$6.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop()\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$7 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$7.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$7.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$7[Symbol.iterator] = function () {\n    var self = this\n    return {next: function () {\n      var token = self.getToken()\n      return {\n        done: token.type === tt.eof,\n        value: token\n      }\n    }}\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$7.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$7.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$7.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$7.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$7.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$7.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos+=startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$7.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n      case 32: case 160: // ' '\n        ++this$1.pos\n        break\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos\n        }\n      case 10: case 8232: case 8233:\n        ++this$1.pos\n        if (this$1.options.locations) {\n          ++this$1.curLine\n          this$1.lineStart = this$1.pos\n        }\n        break\n      case 47: // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42: // '*'\n            this$1.skipBlockComment()\n            break\n          case 47:\n            this$1.skipLineComment(2)\n            break\n          default:\n            break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos\n        } else {\n          break loop\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$7.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$7.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$7.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) {++this.pos; return this.readRegexp()}\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$7.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$7.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$7.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$7.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$7.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$7.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$7.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$7.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$7.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$7.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$7.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$7.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$7.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$7.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$7.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n        case 10:\n          out += \"\\n\"\n          break\n        default:\n          out += String.fromCharCode(ch)\n          break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$7.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$7.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$7.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$7.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"4.0.11\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/acorn/dist/acorn.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}